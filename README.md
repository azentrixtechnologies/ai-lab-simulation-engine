# **ai-lab-simulation-engine**

## Description

Deterministic 3D simulation engine for AI-generated lab experiments.

This service:

* Loads experiment blueprints generated by the Content Engine
* Fetches physics assets from S3 (URDF / GLB)
* Builds a PyBullet simulation scene dynamically
* Runs simulation deterministically
* Streams state frames to frontend (WebSocket)
* Supports offline + edge mode
* Fully domain-configurable (Physics now, Chemistry later)

This is the execution layer between:

Content Engine → Asset Management → Simulation Engine → Frontend

---

# Architecture

```
ai-lab-content-engine
        ↓ (blueprint.json)
ai-lab-asset-service
        ↓ (URDF + GLB + S3 references)
ai-lab-simulation-engine   ← THIS REPO
        ↓ (live states)
ai-lab-backend-api
        ↓
ai-lab-frontend
```

---

# AWS Services Used

* S3 – blueprint + URDF storage
* DynamoDB – experiment metadata
* API Gateway – simulation control
* Lambda – start/stop lightweight simulations
* ECS Fargate – heavy simulations
* ECR – container registry
* CloudWatch – logs
* ElastiCache (Redis) – state caching
* SQS – simulation queue

---

# Folder Structure

```
ai-lab-simulation-engine/
│
├── app/
│   ├── main.py
│   ├── config.py
│   ├── aws.py
│   ├── websocket_server.py
│   │
│   ├── core/
│   │   ├── simulation_runner.py
│   │   ├── blueprint_loader.py
│   │   ├── physics_engine.py
│   │   ├── state_serializer.py
│   │   ├── collision_manager.py
│   │   └── time_manager.py
│   │
│   ├── scenes/
│   │   ├── scene_builder.py
│   │   ├── object_factory.py
│   │   └── constraints_builder.py
│   │
│   ├── domains/
│   │   ├── physics/
│   │   │   ├── motion.py
│   │   │   ├── collision.py
│   │   │   ├── projectile.py
│   │   │   ├── pendulum.py
│   │   │   └── friction.py
│   │   │
│   │   └── chemistry/ (future)
│   │
│   └── utils/
│       ├── logging.py
│       ├── id_generator.py
│       └── math_utils.py
│
├── requirements.txt
├── Dockerfile
└── README.md
```

---

# requirements.txt

```txt
pybullet
boto3
fastapi
uvicorn
websockets
pydantic
redis
numpy
```

---

# config.py

```python
import os

AWS_REGION = os.getenv("AWS_REGION", "ap-south-1")
S3_BUCKET = os.getenv("ASSET_BUCKET")
DYNAMODB_TABLE = os.getenv("EXPERIMENT_TABLE")

SIMULATION_FPS = 60
SIMULATION_TIMESTEP = 1.0 / 240.0
```

---

# aws.py

```python
import boto3
from .config import AWS_REGION

s3 = boto3.client("s3", region_name=AWS_REGION)
dynamodb = boto3.resource("dynamodb", region_name=AWS_REGION)

def download_file(bucket, key, local_path):
    s3.download_file(bucket, key, local_path)
```

---

# blueprint_loader.py

```python
import json
import tempfile
from ..aws import download_file
from ..config import S3_BUCKET

class BlueprintLoader:

    @staticmethod
    def load(experiment_id):
        local_file = tempfile.NamedTemporaryFile(delete=False)

        key = f"experiments/{experiment_id}/blueprint.json"
        download_file(S3_BUCKET, key, local_file.name)

        with open(local_file.name, "r") as f:
            return json.load(f)
```

---

# physics_engine.py

```python
import pybullet as p
import pybullet_data

class PhysicsEngine:

    def __init__(self):
        self.client = p.connect(p.DIRECT)
        p.setAdditionalSearchPath(pybullet_data.getDataPath())
        p.setGravity(0, 0, -9.8)

    def step(self):
        p.stepSimulation()

    def disconnect(self):
        p.disconnect()
```

---

# object_factory.py

```python
import pybullet as p
import tempfile
from ..aws import download_file
from ..config import S3_BUCKET

class ObjectFactory:

    def create_object(self, obj_config):
        """
        obj_config:
        {
            "asset_key": "experiments/exp1/assets/block.urdf",
            "position": [0,0,1],
            "orientation": [0,0,0,1]
        }
        """

        temp = tempfile.NamedTemporaryFile(delete=False)
        download_file(S3_BUCKET, obj_config["asset_key"], temp.name)

        body_id = p.loadURDF(
            temp.name,
            basePosition=obj_config["position"],
            baseOrientation=obj_config["orientation"]
        )

        return body_id
```

---

# scene_builder.py

```python
from .object_factory import ObjectFactory

class SceneBuilder:

    def __init__(self):
        self.factory = ObjectFactory()

    def build(self, blueprint):
        object_ids = []

        for obj in blueprint["objects"]:
            body_id = self.factory.create_object(obj)
            object_ids.append(body_id)

        return object_ids
```

---

# state_serializer.py

```python
import pybullet as p

class StateSerializer:

    @staticmethod
    def serialize(object_ids):
        state = []

        for obj_id in object_ids:
            pos, orn = p.getBasePositionAndOrientation(obj_id)
            vel, ang = p.getBaseVelocity(obj_id)

            state.append({
                "id": obj_id,
                "position": pos,
                "orientation": orn,
                "linear_velocity": vel,
                "angular_velocity": ang
            })

        return state
```

---

# simulation_runner.py

```python
import asyncio
from .physics_engine import PhysicsEngine
from ..scenes.scene_builder import SceneBuilder
from .state_serializer import StateSerializer
from ..config import SIMULATION_TIMESTEP

class SimulationRunner:

    def __init__(self, blueprint):
        self.engine = PhysicsEngine()
        self.scene = SceneBuilder()
        self.objects = self.scene.build(blueprint)

    async def run(self, websocket):
        while True:
            self.engine.step()
            state = StateSerializer.serialize(self.objects)

            await websocket.send_json(state)

            await asyncio.sleep(SIMULATION_TIMESTEP)
```

---

# websocket_server.py

```python
from fastapi import WebSocket

class SimulationWebSocket:

    async def handle(self, websocket: WebSocket, runner):
        await websocket.accept()
        await runner.run(websocket)
```

---

# main.py

```python
from fastapi import FastAPI, WebSocket
from .core.blueprint_loader import BlueprintLoader
from .core.simulation_runner import SimulationRunner
from .websocket_server import SimulationWebSocket

app = FastAPI()

@app.websocket("/simulate/{experiment_id}")
async def simulate(websocket: WebSocket, experiment_id: str):

    blueprint = BlueprintLoader.load(experiment_id)

    runner = SimulationRunner(blueprint)
    handler = SimulationWebSocket()

    await handler.handle(websocket, runner)
```

---

# Example Blueprint (Generated from Content Engine)

```
{
  "experiment_id": "physics_collision_001",
  "domain": "physics",
  "objects": [
    {
      "asset_key": "experiments/physics_collision_001/assets/block_a.urdf",
      "position": [0, 0, 1],
      "orientation": [0, 0, 0, 1]
    },
    {
      "asset_key": "experiments/physics_collision_001/assets/block_b.urdf",
      "position": [2, 0, 1],
      "orientation": [0, 0, 0, 1]
    }
  ]
}
```

---

# Deployment Architecture

## Small Simulation

* Lambda container image
* 1–2 object experiments

## Heavy Simulation

* ECS Fargate
* Auto scaling
* Redis state caching

## Offline Mode

* Run container locally
* PyBullet in DIRECT mode

---

# Flow

1. User selects experiment
2. Frontend calls backend
3. Backend opens WebSocket to Simulation Engine
4. Simulation Engine:

   * Loads blueprint from S3
   * Downloads URDF assets
   * Builds scene
   * Starts PyBullet
   * Streams live state
5. Frontend renders with Three.js

---
